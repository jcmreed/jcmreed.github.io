{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the landing page for direct access to all of JC Reed's indiviual assignments for EGR314!","text":"","tags":["tag1","tag2"]},{"location":"#my-role-in-the-project","title":"My Role in the Project","text":"<p>My role in this project was to design and implement the Human-Machine Interface (HMI) for our interactive STEM exhibit. The purpose of the HMI was to give exhibit-goers an intuitive way to interact with the system and control the sorting mechanism. A more detailed overview of the complete system can be found on my team's webpage.</p> <p>My interface was built around three physical pushbuttons that allow users to navigate through a selection menu and confirm their choices. Feedback and instructions were provided via a compact OLED LCD display, allowing users to see their input in real-time and follow along with the quiz-like experience.</p> <p>In addition to managing user interaction, I was responsible for UART-based communication between my subsystem and the rest of the team. More specifically, the most important messages I sent were structured serial messages to the actuator subsystem to trigger the motor based on the user\u2019s choice. My design ensured that all outgoing messages followed our predefined communication protocol, enabling seamless interaction between the user interface and the rest of the system.</p> <p></p>","tags":["tag1","tag2"]},{"location":"#access-my-teams-webpage-here-team-201s-webpage","title":"Access My Team's Webpage Here: Team 201's Webpage","text":"","tags":["tag1","tag2"]},{"location":"#my-assignments","title":"My Assignments","text":"Assignment Link Block Diagram link Component Selection link Schematic &amp; PCB Design link Bill of Materials link Application Programming Interface (API) link Resources link","tags":["tag1","tag2"]},{"location":"Application%20Programming%20Interface%20%28API%29/","title":"Application Programming Interface (API)","text":""},{"location":"Application%20Programming%20Interface%20%28API%29/#my-role-in-the-daisy-chain","title":"My role in the Daisy Chain","text":"<p>Each team member has their own responsibility on what to send to the chain and how to handle necessary messages from the chain. Again, the subsystem I am responsible for is the Human Machine Interface (HMI). The HMI is where the exhibit user will select a path that they believe matches the color of the element. Listed below is the messaging protocol that the team is using throughout this process. For a more detailed explanation, please refer to this link.</p>"},{"location":"Application%20Programming%20Interface%20%28API%29/#address-ids","title":"Address IDs","text":"Team Member Subsystem ID JC R (myself) Human Machine Interface (HMI) H Eric M RGB Sensor S Marcus P MQTT Server M Bradley P Actuator A ALL Broadcast X"},{"location":"Application%20Programming%20Interface%20%28API%29/#team-message-protocol","title":"Team Message Protocol","text":"Message Type  byte 1 (uint8_t) Description Data Command 0 Status Code 0 (Initialize) 1 Drive Mode 0 (Automatic)  1 (Manual/Direct Drive) 2 Sensor Data 0 (Orange)  1 (Blue)  2 (Pink) 3 Path Selection 0 (Left)  1 (Center)  3 (Right) <p>My  Human Machine Interface uses 3 of these message types. The first one is the status code, which essentially tells the next system in the chain that my system is initialized.</p>"},{"location":"Application%20Programming%20Interface%20%28API%29/#message-type-0-initialization","title":"Message Type 0: Initialization","text":"Byte 1 Byte 2 Var Name msg_type initialize Var Type uint8_t uint8_t Min Val 0 0 Max Val 0 0 Example 0 0 <p>The second message type that my subsystem uses is Message Type 1: Select Mode. This is because when the exhibit user interacts with the HMI, a message must be sent to the chain that the entire system should enter Direct Drive (Manual) Mode. Also, if the user does not interact with the device for a certain amount of time, then the message for autonomous mode is sent.</p>"},{"location":"Application%20Programming%20Interface%20%28API%29/#message-type-1-select-mode","title":"Message Type 1: Select Mode","text":"Byte 1 Byte 2 Var Name msg_type mode Var Type uint8_t uint8_t Min Val 1 0 Max Val 1 1 Example 1 1 <p>The final message type that my subsystem uses is Message Type 3: Select Path. The user must make a path choice on the HMI, and depending on their selection, that's what tells the Actuator where to move to.</p>"},{"location":"Application%20Programming%20Interface%20%28API%29/#message-type-3-select-path","title":"Message Type 3: Select Path","text":"Byte 1 Byte 2 Var Name msg_type path Var Type uint8_t uint8_t Min Val 3 0 Max Val 3 2 Example 3 1"},{"location":"Application%20Programming%20Interface%20%28API%29/#handling-messages-code","title":"Handling Messages (Code)","text":"<pre><code># --- Imports ---\nfrom machine import UART, Pin\nimport time\nimport uasyncio as asyncio\n\n# --- Constants and Configuration ---\nMAX_MESSAGE_LEN = 64  # Max message length to protect buffer overflow\nteam = [b'H', b'M', b'A', b'S']  # Valid team device IDs\nid = b'H'                        # This device's ID\nbroadcast = b'X'                # Broadcast ID for sending to all devices\n\n# Message type definitions and valid data ranges\nVALID_MESSAGE_TYPES = {\n    0x00: [0x00],                    # Status Code\n    0x01: [0x00, 0x01],              # Drive Mode\n    0x02: [0x00, 0x01, 0x02],        # Sensor Data\n    0x03: [0x00, 0x01, 0x02]         # Path Selection\n}\n\n# --- Hardware Initialization ---\n# UART2 with TX on GPIO17, RX on GPIO18\nuart = UART(2, 9600, tx=17, rx=18)\nuart.init(9600, bits=8, parity=None, stop=1)\n\n# Onboard LED for visual feedback (GPIO 7)\nled = Pin(7, Pin.OUT)\n\n# --- Message Sending Function ---\ndef send_message(sender, receiver, msg_type, data):\n    # Validate sender, receiver, type, and data\n    if sender not in team:\n        print(\"Error: Invalid sender ID.\")\n        return\n    if receiver not in team and receiver != broadcast:\n        print(\"Error: Invalid receiver ID.\")\n        return\n    if msg_type not in VALID_MESSAGE_TYPES or data not in VALID_MESSAGE_TYPES[msg_type]:\n        print(\"Error: Invalid message type or data value.\")\n        return\n\n    # Construct and send the UART message\n    message = b\"AZ\" + sender + receiver + bytes([msg_type]) + bytes([data]) + b\"YB\"\n    uart.write(message)\n    print(f\"Sent: {message}\")\n\n# --- Message Receiving and Handling Function ---\ndef handle_message(message):\n    try:\n        # Basic message size validation\n        if len(message) &lt; 7:\n            print(\"ESP: Message too short, deleting.\")\n            return\n        if len(message) &gt; MAX_MESSAGE_LEN:\n            print(\"ESP: Message too long, deleting.\")\n            return\n\n        # Parse message structure\n        prefix = message[:2]\n        sender = message[2:3]\n        receiver = message[3:4]\n        msg_type = message[4] \n        data = message[5] \n        suffix = message[-2:]\n\n        # Check for proper framing\n        if prefix != b\"AZ\" or suffix != b\"YB\":\n            print(\"ESP: Invalid message format, deleting.\")\n            return\n\n        # Validate sender and receiver\n        if sender not in team:\n            print(f\"ESP: Invalid sender {sender}, deleting.\")\n            return\n        if receiver not in team and receiver != broadcast:\n            print(f\"ESP: Invalid receiver {receiver}, deleting.\")\n            return\n\n        # Validate message type and associated data\n        if msg_type not in VALID_MESSAGE_TYPES:\n            print(f\"ESP: Invalid message type {msg_type}, deleting.\")\n            return\n        if data not in VALID_MESSAGE_TYPES[msg_type]:\n            print(f\"ESP: Invalid data value {data} for message type {msg_type}, deleting.\")\n            return\n\n        # Drop message if it's from self\n        if sender == id:\n            print(\"ESP: Deleted own message.\")\n            return\n\n        # Act on messages addressed to this device or broadcast\n        if receiver == id or receiver == broadcast:\n            print(f\"ESP: Received message from {sender.decode()}! Type {msg_type}, Data {data}\")\n            led.value(led.value() ^ 1)  # Toggle LED for activity feedback\n\n        # Forward messages not intended for this device\n        if receiver != id and receiver != broadcast:\n            print(f\"ESP: Forwarding message to {receiver.decode()}\")\n            uart.write(message)\n\n    except Exception as e:\n        print(f\"ESP: Error processing message: {e}\")\n\n# --- Asynchronous Task: UART Receiver ---\nasync def process_rx():\n    stream = b''              # Buffer for collecting bytes\n    receiving_message = False # Flag for message collection state\n\n    while True:\n        c = uart.read(1)  # Read 1 byte at a time\n\n        if c:\n            stream += c\n\n            # Detect message start\n            if stream[-2:] == b'AZ':\n                receiving_message = True\n                stream = b'AZ'  # Reset buffer with prefix only\n\n            # Detect complete message\n            if receiving_message and stream[-2:] == b'YB':\n                receiving_message = False\n                handle_message(stream)\n                stream = b''\n\n            # Drop overlong messages\n            if len(stream) &gt; MAX_MESSAGE_LEN:\n                print(\"ESP: Message too long, deleting.\")\n                stream = b''\n                receiving_message = False\n\n        await asyncio.sleep_ms(10)\n\n# --- Asynchronous Task: Heartbeat / Test Ping ---\nasync def heartbeat():\n    while True:\n        print('ESP: Sending Test Code')\n        # Uncomment below to send a sample message for testing\n        # send_message(b'S', id, 0x02, 0x02)\n        # uart.write(b'AZHX\\x00\\x03\\x03YB')\n        await asyncio.sleep(10)\n\n# --- Main Loop (placeholder for future tasks) ---\nasync def main():\n    while True:\n        await asyncio.sleep(1)\n\n# --- Task Scheduling ---\nasyncio.create_task(process_rx())     # Start UART receiver\nasyncio.create_task(heartbeat())      # Start heartbeat sender\n\n# --- Run Event Loop ---\ntry:\n    asyncio.run(main())\nfinally:\n    asyncio.new_event_loop()  # Reset event loop if interrupted\n</code></pre>"},{"location":"Bill%20of%20Materials/","title":"Bill of Materials","text":""},{"location":"Bill%20of%20Materials/#link-for-higher-visibility","title":"Link for Higher Visibility","text":"<ul> <li>Complete BOM (.xlsx)</li> </ul>"},{"location":"Block%20Diagram/","title":"Block Diagram","text":""},{"location":"Block%20Diagram/#_1","title":"Block Diagram","text":""},{"location":"Block%20Diagram/#decision-making-process-meeting-requirments","title":"Decision Making Process &amp; Meeting Requirments","text":"<p>For deeper context, the Element Sorter project challenged Team 201 to design an interactive STEM exhibit for middle school students, wherein users engage in a gamified element-sorting activity. My responsibility focused on developing the Human-Machine Interface (HMI) to enable user interaction, provide feedback, and maintain communication across subsystems.</p> <p>As depicted in my block diagram above, I selected the ESP32 microcontroller for its 3.3V functionality, UART support, and our team's familiarity with its I2C and OLED interfacing from classroom labs \u2014 facilitating smooth development of the graphical interface that distinguishes my subsystem through visual interactivity. User input relies on three GPIO pushbuttons connected to digital input pins (IO4, IO5, IO6), chosen for their reliability/familiarity in classroom environments. The block diagram identifies these connections as \"digital @ 3.3V --&gt; parallel (1 pin each)\" to indicate the direct logic-level interaction.</p> <p>My subsystem employs UART for serial communication with other components using the predefined protocol structure (prefix, sender, receiver, message type, data, suffix), while I2C connects to the OLED display via two pins, labeled as \"digital @ 3.3V --&gt; serial (2 pins).\" The power management incorporates a jumper-selectable input system accepting either 9V from a barrel jack or 5V USB, both regulated to 3.3V through a switching regulator \u2014 reflected in the block diagram as \"analog @ 9V --&gt; power input (1 line)\" and \"analog @ 3.3V --&gt; DC power (1 line).\"</p> <p>Overall, my development approach prioritized educational value and user engagement while meeting the project's technical constraints \u2014 selecting components and communication protocols based on reliability, compatibility, and previous experience. The resulting block diagram comprehensively illustrates all subsystem interconnections (UART headers), communicates the appropriate voltage levels and protocols, and satisfies our product requirements by enabling the interactive, educational experience regarding the Element Sorter's function \u2014 demonstrating how the HMI subsystem supports the broader objective of teaching periodic table concepts through engaging, hands-on interaction.</p>"},{"location":"Component%20Selection/","title":"Component Selection","text":""},{"location":"Component%20Selection/#table-1-selecting-a-pushbutton","title":"Table 1: Selecting a Pushbutton","text":"Potential Solutions Pros Cons  Option #1: PTS636SM43SMTR LFS Surface Mount Push Button ($0.23) link to product - Good PCB Contact  - Tactile  - Inexpensive - Long Shipping Time  - Small for User Interactivity  Option #2: Gikfun Tactile Surface Mount Push Button ($8.68)  link to product - Fun and Colorful for Exhibit  - Tactile  - Fast Shipping - Expensive  - Comes in Bulk  - Must Reorientate Pins for PCB  Option #3: K8WH41G LFS Tactile Surface Mount Push Button w/ LED ($6.45)  link to product - LED for Exhibit Experience  - Tactile - Long Shipping Time  - Extra Pins for LED Control  - Must Buy Other Buttons for Different LED Color <p>Choice: Option #2: Gikfun Tactile Surface Mount Push Button Rationale: This option was selected due to the extreme amount of customizability available. Considering the team's STEM exhibit works closely with color recognition, it was important to select something that works well within the theme. Also, these buttons funtion to provide excellent tactile feedback while offering a level of interactivity other options cannot. While it's true that this option was the most expensive, it remains in the range of budget.</p>"},{"location":"Component%20Selection/#table-2-selecting-an-oled-screen","title":"Table 2: Selecting an OLED Screen","text":"Potential Solutions Pros Cons  Option #1: Songhe 0.96inch OLED LCD Display Board (~$2.00 per board) link to product - I2C Serial Communication  - 5 Pack  - Provided from ASU - No Price Listed  - Small Resolution  - Might be Difficult for Users to See  Option #2: Winstar Graphic LCD Display Module ($7.02)  link to product - I2C Serial Communication  - Easy Communication w/ ESP32  - Small Resolution  - Not Provided from ASU  - Might be Difficult for Users to See  Option #3: HiLetgo 0.91inch I2C Serial OLED LCD Display ($6.49)  link to product - I2C Serial Communication  - Rectangular Display  - Fast Shipping - Small Resolution  - Not Provided from ASU <p>Choice: Option #1: Songhe 0.96inch OLED LCD Display Board Rationale: Overall, all solutions in this table were very similar and varied only by price and display size. The reason option #1 was selected was due to the fact that ASU provides the screen, which saves money and shipping time. Familiarity with this device will be gained through in-class labs as well.</p>"},{"location":"Component%20Selection/#table-3-selecting-a-voltage-regulator","title":"Table 3: Selecting a Voltage Regulator","text":"Potential Solutions Pros Cons  Option #1: AP2114H-3.3TRG1 Linear Voltage Regulator ($0.61)  link to product - Meets Requirements  - Inexpensive  - Compact Design - Requires External Components  - 6V Input  - Linear, not Adjustable  Option #2: L6981C33DR - Buck Switching Regulator ($2.80)  link to product - High Efficiency  - Adjustable and Fixed Capabilities  - Compact Design - Requires External Components  - Expensive for Regulator   Option #3: SC189ZSKTRT - 3.3V Buck Switching Regulator ($1.89)  link to product - High Efficiency  - Inexpensive  - Compact Design - Requires External Components  - Soldering Might be Difficult  <p>Choice: Option #2: L6981C33DR - 3.3V Buck Switching Regulator Rationale: This solution was selected as it meets all project requirements with high efficiency as well. While it does require extra components, the datasheet helps identify a proper setup for good results. Even though this option is expensive for a regulator, this is a necessary tradeoff to take as it implements functionality better than other options. </p>"},{"location":"Component%20Selection/#table-4-selecting-a-power-supply","title":"Table 4: Selecting a Power Supply","text":"Potential Solutions Pros Cons  Option #1: WR9HD1333CCP-F(R6B) - 9V 12 W AC/DC External Wall Mount ($3.94)  link to product - Barrel Jack Output  - Inexpensive  - 1.33A (Sufficient for ESP32, Might Need More Room for Other Peripherals)  - Long Shipping Time  Option #2: WSU090-2000-13 - 9V 18 W AC/DC External Wall Mount ($12.15)   link to product - Barrel Jack Output  - 2A Supply  - Expensive  - Long Shipping Time  - Bulky Design  Option #3: BestCH 9V 3.0A AC Power Supply Adapter ($4.52)  link to product - Barrel Jack Output  - 3A Supply  - Provided by ASU  - Bulky Design  - Datasheet not Provided <p>Choice: Option #3: BestCH 9V 3.0A AC Power Supply Adapter Rationale: The rationale behind this selection is the fact that is can provide up to 3.0A of current for the subsystem. This is more than enough to allow for complete functionality. Furthermore, this component is provided by ASU and allows finances to be focused into other areas. Although this design is bulky, it does the best at meeting project requirements. </p>"},{"location":"Component%20Selection/#microcontroller-used-esp32-s3-wroom-1-n4","title":"Microcontroller Used: ESP32-S3-WROOM-1-N4","text":"ESP Info Answer Model S3-WROOM-1-N4 Product Page URL link ESP32-S3-WROOM-1-N4 Datasheet URL link ESP32 S3 Datasheet URL link ESP32 S3 Technical Reference Manual URL link Vendor link link Code Examples Arduino Example w/ LCD StackExchange Forum External Resources URL(s) Expressif Tutorial YouTube Tutorial (Good w/ BLE) Unit cost $2.95 Absolute Maximum Current for entire IC 1500mA Supply Voltage Range 3.0V - 3.6V (3.3V is Typical) Absolute Maximum current  (for VDD3P3) 500mA Maximum GPIO current  (per pin) 40mA Supports External Interrupts? Yes Required Programming Hardware, Cost, URL Schematic Checklist PCB Layout Design Hardware Development"},{"location":"Component%20Selection/#pin-layout","title":"Pin Layout","text":""},{"location":"Component%20Selection/#pin-allocation","title":"Pin Allocation","text":"Peripheral Pin Assignment (Name, Number) Power 3V3, 2 Ground GND, 1  GND, 40  GND, 41 USB IO19, 13 (D-)  IO20, 14 (D+) UART IO17, 10 (Tx)  TX18, 11 (Rx) I2C IO21, 23 (SCL)  IO47, 24 (SDA) GPIO IO4, 4  IO5, 5  IO6, 6"},{"location":"Component%20Selection/#summary-table-all-components-selected","title":"Summary Table (All Components Selected)","text":"Component Selected Image ESP32-S3-WROOM-1-N4 Microcontroller ($2.95) BestCH 9V 3.0A AC Power Supply Adapter ($4.52) L6981C33DR - Buck Switching Regulator ($2.80) Songhe 0.96inch OLED LCD Display Board (~$2.00 per board)"},{"location":"Component%20Selection/#decision-making-process-meeting-requirements","title":"Decision Making Process &amp; Meeting Requirements","text":"<p>Component selection for my Human-Machine Interface (HMI) subsystem prioritized creating a responsive, reliable interface for our middle school-targeted STEM exhibit. As mentioned previously, the interface necessitated real-time feedback, intuitive interaction, and robust inter-subsystem communication \u2014 driving my selection of components offering dependable performance, 3.3V logic compatibility, and seamless integration capabilities.</p> <p>All components adhered to key requirements: implementation of serial communication protocols (UART and I2C), operation at 3.3V, and compliance with the standardized message structure shared across subsystems. I favored components readily available through course materials to minimize procurement challenges, decrease budget allocation, and ensure consistent support throughout development. User engagement factored heavily into my decisions \u2014 selecting components that would enhance functionality and appeal within an interactive educational environment designed for younger users.</p> <p>My major component selections included the ESP32-S3-WROOM-1-N4 microcontroller for its integrated UART and I2C capabilities, 3.3V logic, compact form factor, and our team's familiarity with it from previous laboratory exercises \u2014 providing sufficient GPIO pins for pushbutton integration while supporting the required communication protocols. The Songhe 0.96\" OLED Display (I2C, 3.3V) was chosen for its minimal footprint, display clarity, and ESP32 compatibility via I2C \u2014 additionally offering pre-approval and availability through course resources, thus reducing integration complexity. Gikfun Tactile Pushbuttons delivered essential tactile feedback and colorful aesthetics that enhanced exhibit interactivity for younger users, while offering straightforward implementation with GPIO pins and familiar digital logic. The L6981C33DR 3.3V Switching Regulator supplied an efficient, high-current (1.5A) 3.3V output from either 5V USB or 9V barrel jack inputs \u2014 selected for its optimal balance of current capacity, cost-effectiveness, and suitability for our dual-input configuration.</p>"},{"location":"Component%20Selection/#power-budget","title":"Power Budget","text":"<p>To ensure stable operation of my Human-Machine Interface (HMI) subsystem, I created the following power budget to estimate the current draw of the major components (OLED and Microcontroller) and verify that my selected power and regulation system could meet those needs under typical and peak loads.</p> <p>My system is powered through one of two selectable input sources:</p> <ul> <li>A BestCH 9V 3.0A AC Power Supply Adapter</li> <li>A 5V USB connection (typically 500mA\u20131.5A depending on host capability). (The jumper-based selection system ensures that only one source is active at a time.)</li> </ul> <p>Both input options feed into the L6981C33DR buck switching regulator, which efficiently converts input voltage down to 3.3V. This regulator supports up to 1.5A output current, which is well above the estimated system load. Take a look at the full power budget below.</p> <p></p> <p>The power budget is extremely useful in providing viable component options that safely operate the entire board. This process acts as confirmation and reassurance, while eliminating overall risks of damaging devices. Furthermore, my power budget confirmed that the L6981C33DR switching regulator can comfortably supply the required current, even under peak activity. With a maximum output of 1.5A, it operates with a wide safety margin, ensuring stability and thermal headroom.</p> <p>The BestCH 9V 3.0A adapter provides more than enough current on the input side to support the regulator\u2019s output, and the USB option is sufficient for low-power testing or debugging. Overall, the power system is robust, efficient, and meets all electrical requirements for continuous exhibit use.</p>"},{"location":"Resources/","title":"Resources","text":""},{"location":"Resources/#video-showcasing-final-hmi-subsystem","title":"Video Showcasing Final HMI Subsystem","text":""},{"location":"Resources/#entire-micropython-code","title":"Entire Micropython Code","text":"<pre><code># --- Imports ---\nimport my_oled\nimport time\nimport uasyncio as asyncio\nfrom machine import UART, Pin\nimport random\n\n# --- Debug Mode (Optional Simulation) ---\nTEST_MODE = False\nTEST_COLOR_NAME = \"orange\"  # Simulated color if TEST_MODE is True\n\n# --- UART and Message Constants ---\nMAX_MESSAGE_LEN = 64\nteam = [b'H', b'M', b'A', b'S']   # Team device IDs\nid = b'H'                         # This HMI device ID\nbroadcast = b'X'                 # Broadcast ID\n\n# Valid message types and allowed data\nVALID_MESSAGE_TYPES = {\n    0x00: [0x00],                   # Status Code\n    0x01: [0x00, 0x01],             # Drive Mode (0 = Auto, 1 = Manual)\n    0x02: [0x00, 0x01, 0x02],       # Sensor Color Data\n    0x03: [0x00, 0x01, 0x02]        # Path Selection (User choice)\n}\n\n# Color codes sent from sensor\nCOLOR_CODES = {\n    \"orange\": 0x00,\n    \"blue\": 0x01,\n    \"green\": 0x02,\n}\n\n# Elements mapped by color/category\nELEMENTS = {\n    0x00: [\"Aluminum\", \"Gold\", \"Silver\", \"Iron\", \"Calcium\", \"Sodium\", \"Copper\", \"Mercury\", \"Platinum\"],     # Metals\n    0x01: [\"Hydrogen\", \"Carbon\", \"Nitrogen\", \"Oxygen\", \"Sulfur\", \"Chlorine\", \"Helium\", \"Neon\", \"Krypton\"],  # Non-Metals\n    0x02: [\"Boron\", \"Silicon\", \"Germanium\", \"Arsenic\", \"Antimony\", \"Tellurium\"],                            # Metalloids\n}\n\n# Element symbols for display\nELEMENT_SYMBOLS = {\n    \"Aluminum\": \"Al\", \"Gold\": \"Au\", \"Silver\": \"Ag\", \"Iron\": \"Fe\", \"Calcium\": \"Ca\", \"Sodium\": \"Na\",\n    \"Copper\": \"Cu\", \"Mercury\": \"Hg\", \"Platinum\": \"Pt\", \"Hydrogen\": \"H\", \"Carbon\": \"C\", \"Nitrogen\": \"N\",\n    \"Oxygen\": \"O\", \"Sulfur\": \"S\", \"Chlorine\": \"Cl\", \"Helium\": \"He\", \"Neon\": \"Ne\", \"Krypton\": \"Kr\",\n    \"Boron\": \"B\", \"Silicon\": \"Si\", \"Germanium\": \"Ge\", \"Arsenic\": \"As\", \"Antimony\": \"Sb\", \"Tellurium\": \"Te\"\n}\n\n# --- UI State Variables ---\nbins = [\"Metal\", \"Non-Metal\", \"Metalloid\"]\nyesno = [\"YES\", \"NO\"]\nselected_element = 0\nyesno_selection = 0\ndetected_color = None\ncurrent_element = \"\"\nautonomous_sent = False\nled_should_blink = False\n\n# --- Hardware Setup ---\nuart = UART(2, 9600, tx=17, rx=18)\nuart.init(9600, bits=8, parity=None, stop=1)\nled = Pin(7, Pin.OUT)\n\n# --- Button State Tracking ---\nprevious_up = 1\nprevious_down = 1\nprevious_select = 1\n\n# --- State Machine Definitions ---\nwelcome_state = 0\ndrive_state = 1\nconf_state = 2\nfeedback_state = 3\nstate = welcome_state\nlast_input_time = time.time()\n\n# --- OLED Display Functions ---\ndef Welcome_Display():\n    my_oled.oled.fill(0)\n    my_oled.print_text(\"WELCOME TO THE\", 7, 0)\n    my_oled.print_text(\"ELEMENT SORTER!\", 6, 10)\n    my_oled.print_text(\"PRESS THE\", 26, 35)\n    my_oled.print_text(\"SELECT\", 38, 45)\n    my_oled.print_text(\"~      ~\", 29, 47)\n    my_oled.print_text(\"BUTTON TO BEGIN!\", 2, 55)\n    my_oled.oled.show()\n\ndef Bin_Display():\n    # Display the selected element and bin choices\n    my_oled.oled.fill(0)\n    my_oled.print_text(\"WHAT TYPE OF\", 15, 0)\n    my_oled.print_text(\"ELEMENT IS:\", 20, 10)\n    my_oled.print_text(current_element, 28, 22)\n    symbol = ELEMENT_SYMBOLS.get(current_element, \"??\")\n    my_oled.oled.rect(2, 34, 30, 30, 1)\n    my_oled.print_text(symbol, 10, 45)\n    for i, bin_name in enumerate(bins):\n        y_pos = 36 + (i * 10)\n        if i == selected_element:\n            my_oled.oled.fill_rect(41, y_pos - 2, 78, 10, 1)\n            my_oled.print_text(bin_name, 43, y_pos, 0)\n        else:\n            my_oled.print_text(bin_name, 43, y_pos, 1)\n    my_oled.oled.show()\n\ndef Conf_Display():\n    # Display confirmation screen before sending user's answer\n    my_oled.oled.fill(0)\n    my_oled.print_text(\"YOU'VE SELECTED:\", 0, 0)\n    my_oled.print_text(bins[selected_element], 17, 10)\n    my_oled.print_text(\"CONFIRM?\", 0, 30)\n    for i, conf in enumerate(yesno):\n        y_pos = 40 + (i * 10)\n        if i == yesno_selection:\n            my_oled.oled.fill_rect(10, y_pos - 2, 30, 10, 1)\n            my_oled.print_text(conf, 12, y_pos, 0)\n        else:\n            my_oled.print_text(conf, 12, y_pos, 1)\n    my_oled.oled.show()\n\ndef Feedback_Display(correct, correct_category=None):\n    # Show if the answer was correct/incorrect\n    my_oled.oled.fill(0)\n    if correct:\n        my_oled.print_text(\"YOU ARE\", 35, 10)\n        my_oled.print_text(\"CORRECT!\", 33, 20)\n    else:\n        my_oled.print_text(\"YOU ARE\", 35, 0)\n        my_oled.print_text(\"INCORRECT!\", 28, 9)\n        if correct_category:\n            my_oled.print_text(\"Answer:\", 0, 26)\n            my_oled.print_text(correct_category, 55, 26)\n    my_oled.print_text(\"DETECTING NEW\", 10, 46)\n    my_oled.print_text(\"ELEMENT...\", 25, 56)\n    my_oled.oled.show()\n\n# --- UART Messaging ---\ndef send_message(sender, receiver, msg_type, data):\n    # Validate and send formatted UART message\n    if sender not in team or (receiver not in team and receiver != broadcast): return\n    if msg_type not in VALID_MESSAGE_TYPES or data not in VALID_MESSAGE_TYPES[msg_type]: return\n    msg = b\"AZ\" + sender + receiver + bytes([msg_type]) + bytes([data]) + b\"YB\"\n    uart.write(msg)\n\ndef handle_color_detection(color_code):\n    global detected_color, current_element\n    detected_color = color_code\n    current_element = random.choice(ELEMENTS[detected_color])\n\ndef reset_to_welcome():\n    # Reset UI state to welcome screen\n    global state, selected_element, yesno_selection, previous_up, previous_down, previous_select\n    selected_element = 0\n    yesno_selection = 0\n    previous_up = 1\n    previous_down = 1\n    previous_select = 1\n    state = welcome_state\n    Welcome_Display()\n\ndef handle_message(msg):\n    global state, last_input_time, autonomous_sent, led_should_blink\n    if len(msg) &lt; 7 or len(msg) &gt; MAX_MESSAGE_LEN: return\n    if not (msg.startswith(b\"AZ\") and msg.endswith(b\"YB\")): return\n    sender, receiver = msg[2:3], msg[3:4]\n    msg_type, data = msg[4], msg[5]\n    if sender == id: return  # Ignore self\n\n    if receiver == id or receiver == broadcast:\n        if msg_type == 0x00 and data == 0x00:\n            led_should_blink = True\n        elif msg_type == 0x02:\n            handle_color_detection(data)\n        elif msg_type == 0x01 and data == 0x00:\n            reset_to_welcome()\n            autonomous_sent = True\n            send_message(id, broadcast, 0x01, 0x00)\n\n    # Always forward valid messages not from self\n    if sender != id:\n        uart.write(msg)\n\n# --- Async UART Message Receiver ---\nasync def process_rx():\n    buf = b''\n    receiving = False\n    while True:\n        c = uart.read(1)\n        if c:\n            buf += c\n            if buf[-2:] == b'AZ': buf, receiving = b'AZ', True\n            if receiving and buf[-2:] == b'YB':\n                receiving = False\n                handle_message(buf)\n                buf = b''\n            if len(buf) &gt; MAX_MESSAGE_LEN:\n                buf = b''\n                receiving = False\n        await asyncio.sleep_ms(10)\n\n# --- Async LED Blink (status indicator) ---\nasync def blink_led():\n    while True:\n        if led_should_blink:\n            led.value(not led.value())\n        await asyncio.sleep_ms(500)\n\n# --- Main HMI Event Loop ---\nasync def hmi_loop():\n    global previous_up, previous_down, previous_select\n    global selected_element, yesno_selection, state, last_input_time, autonomous_sent\n\n    Welcome_Display()\n\n    # Inject test message if enabled\n    if TEST_MODE and TEST_COLOR_NAME in COLOR_CODES:\n        await asyncio.sleep(1)\n        test_msg = b\"AZ\" + b'S' + id + bytes([0x02]) + bytes([COLOR_CODES[TEST_COLOR_NAME]]) + b\"YB\"\n        handle_message(test_msg)\n\n    while True:\n        current_up = my_oled.buttonUP.value()\n        current_down = my_oled.buttonDOWN.value()\n        current_select = my_oled.buttonSELECT.value()\n        now = time.time()\n\n        # Auto-reset if no activity for 2 minutes\n        if now - last_input_time &gt; 120 and not autonomous_sent:\n            reset_to_welcome()\n            if detected_color is not None:\n                send_message(id, broadcast, 0x01, 0x00)\n                autonomous_sent = True\n\n        # --- State Logic ---\n        if state == welcome_state:\n            if current_select == 0 and previous_select == 1:\n                last_input_time = now\n                state = drive_state\n                Bin_Display()\n                send_message(id, broadcast, 0x01, 0x01)\n                autonomous_sent = False\n\n        elif state == drive_state:\n            if current_up == 0 and previous_up == 1:\n                selected_element = (selected_element - 1) % len(bins)\n                Bin_Display()\n                last_input_time = now\n            if current_down == 0 and previous_down == 1:\n                selected_element = (selected_element + 1) % len(bins)\n                Bin_Display()\n                last_input_time = now\n            if current_select == 0 and previous_select == 1:\n                state = conf_state\n                Conf_Display()\n                last_input_time = now\n\n        elif state == conf_state:\n            if current_up == 0 and previous_up == 1:\n                yesno_selection = (yesno_selection - 1) % 2\n                Conf_Display()\n                last_input_time = now\n            if current_down == 0 and previous_down == 1:\n                yesno_selection = (yesno_selection + 1) % 2\n                Conf_Display()\n                last_input_time = now\n            if current_select == 0 and previous_select == 1:\n                if yesno_selection == 0:\n                    send_message(id, b'X', 0x03, selected_element)\n                    correct = selected_element == detected_color\n                    correct_category = bins[detected_color]\n                    Feedback_Display(correct, correct_category)\n                    await asyncio.sleep(6)\n                    state = drive_state\n                    Bin_Display()\n                else:\n                    state = drive_state\n                    Bin_Display()\n                last_input_time = now\n\n        # Save current button states\n        previous_up = current_up\n        previous_down = current_down\n        previous_select = current_select\n        await asyncio.sleep(0.01)\n\n# --- Main Program Startup ---\nasync def main():\n    led.value(1)  # LED solid on at start\n    send_message(id, b'S', 0x00, 0x00)  # Status update\n    asyncio.create_task(process_rx())\n    asyncio.create_task(blink_led())\n    asyncio.create_task(hmi_loop())\n    while True:\n        await asyncio.sleep(1)\n\n# --- Run Program ---\ntry:\n    asyncio.run(main())\nfinally:\n    asyncio.new_event_loop()  # Ensure loop cleanup\n</code></pre>"},{"location":"Resources/#zip-file-full-esp32-code-project","title":"ZIP File (Full ESP32 Code Project)","text":""},{"location":"Resources/#cad-modeling-used-oled-stand-pcb-baseplate","title":"CAD Modeling Used (OLED Stand + PCB Baseplate)","text":"PCB Mount Full HMI Display Mounting Arm OLED Mount"},{"location":"Resources/#zip-file-cad-files-screenshots","title":"ZIP File (CAD Files + Screenshots)","text":""},{"location":"Schematic%20%26%20PCB%20Design/","title":"Schematic & PCB Design","text":""},{"location":"Schematic%20%26%20PCB%20Design/#schematic-design","title":"Schematic Design","text":""},{"location":"Schematic%20%26%20PCB%20Design/#_1","title":"Schematic & PCB Design","text":""},{"location":"Schematic%20%26%20PCB%20Design/#printed-circuit-board-pcb-design","title":"Printed Circuit Board (PCB) Design","text":"<p>Front View Back View </p>"},{"location":"Schematic%20%26%20PCB%20Design/#links-for-high-resolution-visibility","title":"Links for High Resolution Visibility","text":"<ul> <li>PDF (Schematic)</li> <li>PDF (PCB)</li> <li>Combined ECAD Folder (Schematic + PCB)</li> </ul>"},{"location":"Schematic%20%26%20PCB%20Design/#decision-making-process-meeting-requirements","title":"Decision Making Process &amp; Meeting Requirements","text":"<p>The HMI subsystem schematic/PCB integrates power regulation, user input mechanisms, visual feedback elements, and inter-subsystem communication capabilities into a cohesive, reliable design \u2014 fulfilling both the technical product requirements and user interaction goals for our middle school-targeted STEM exhibit.</p> <p>The ESP32-S3-WROOM-1-N4 microcontroller forms the core of the design, connected to three GPIO-driven pushbuttons, an I2C OLED display, and UART lines that enable communication with other subsystems. Each pushbutton incorporates hardware debouncing via 10k\u03a9 pull-up resistors complemented by software filtering to ensure clean signal transitions and responsive user interaction. The I2C data lines (SDA/SCL) feature 4.7k\u03a9 pull-up resistors that maintain reliable OLED display communication in accordance with I2C specifications.</p> <p>To satisfy the 3.3V system voltage requirement, the schematic employs the L6981C33DR buck switching regulator with jumper-selectable power input from either a 9V 3.0A barrel jack or 5V USB source. Input/output capacitors positioned at the regulator's VIN and VOUT pins maintain voltage stability, while local decoupling capacitors near the ESP32 and display minimize noise and ensure stable operation.</p> <p>Programming and debugging capabilities include USB D+ and D\u2212 lines routed to the appropriate ESP32-S3 USB-capable pins (IO19, 20) for native USB programming, a standard BOOT circuit utilizing IO0, and the EN pin with pull-up to facilitate manual flashing when necessary. Two UART headers enable communication with other subsystems, fulfilling our serial protocol requirement, while a current-limited blue status LED provides users with a clear power-on indication \u2014 an essential visual cue for exhibit functionality.</p> <p>The layout features widened power traces to accommodate expected current flow safely. Although only the top layer includes a ground plane for improved signal integrity and thermal performance, the absence of a bottom-side ground plane represents a minor oversight for future revision. Nevertheless, the component placement and routing support reliable operation and serviceability.</p> <p>The schematic successfully incorporates all required functionalities into a logical, robust system \u2014 enabling intuitive user interaction, meeting power and communication specifications, and implementing standard hardware design practices such as decoupling, pull-ups, and regulated voltage supply to ensure long-term functionality in the educational environment.</p>"},{"location":"Schematic%20%26%20PCB%20Design/#version-20-of-pcb-design","title":"Version 2.0 of PCB Design","text":"<p>While my schematic design was functionally sound\u2014resulting in a fully working HMI subsystem\u2014there are several hardware layout issues I would address in a Version 2.0 revision. Most notably, I initially routed the UART lines to RX0 and TX0, which conflicted with the ESP32\u2019s USB REPL interface. I had to bypass this using jumper wires to reassign UART to alternate GPIOs, which worked but was a workaround rather than a clean solution.</p> <p>Additionally, I accidentally mirrored the pinout of my 2x4 UART header, reversing the order of pins 1\u20138. This made the pre-designed ribbon cables incompatible with the PCB and forced me to fabricate a custom cable to match our team's required format\u2014where pin 1 was 3.3V power, pin 2 was communication, and pin 8 was ground.</p> <p>Another layout issue was the placement of the OLED header, which ended up too close to the user pushbuttons. To resolve this, I 3D-printed a small riser and used fly wires to elevate and reposition the screen.</p> <p>Finally, while I included a ground plane on the top layer, I neglected to fill the bottom layer, which would have improved noise immunity and thermal performance. These changes would significantly improve reliability and usability in a future revision.</p>"},{"location":"Schematic%20%26%20PCB%20Design/#team-pcb-design","title":"Team PCB Design","text":"<p>As pictured above, Team 201 comprised four members, each assigned to a specific subsystem (left-to-right): Human-Machine Interface (HMI), Sensor, MQTT, and Actuator \u2014 arranged in a daisy-chain communication configuration that reflected the logical progression of user interaction. This sequence began with the HMI initiating the process, followed by the sensor detecting a ball, MQTT functioning as the communication bridge, and concluding with the actuator repositioning the ball according to user selection.</p> <p>Our design decisions responded directly to both project goals and class requirements \u2014 particularly the mandated UART-based message structure and 2x4 ribbon cable pinout standard that ensured cross-subsystem compatibility while providing a unified technical foundation for development.</p> <p>Microcontroller selection balanced practicality and performance considerations \u2014 implementing the ESP32 for both HMI and MQTT subsystems due to our familiarity with it from previous laboratory exercises and its compatibility with I2C, UART, and USB programming protocols. Conversely, PIC microcontrollers served the sensor and actuator subsystems, selected for their precise timing capabilities and robust hardware interfacing options.</p> <p>Integration and debugging processes occurred collaboratively to validate communication pathways and system workflow. My HMI hardware decisions \u2014 including UART pin mapping and header configuration \u2014 required careful coordination with teammates to ensure seamless connectivity and interaction throughout the Element Sorter device.</p>"},{"location":"static/node_modules/mathjax/","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#beautiful-math-in-all-browsers","title":"Beautiful math in all browsers","text":"<p>MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.  It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems.  It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily.  Simply include MathJax and some mathematics in a web page, and MathJax does the rest.</p> <p>Some of the main features of MathJax include:</p> <ul> <li> <p>High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages</p> </li> <li> <p>Supported in most browsers with no plug-ins, extra fonts, or special   setup for the reader</p> </li> <li> <p>Easy for authors, flexible for publishers, extensible for developers</p> </li> <li> <p>Supports math accessibility, cut-and-paste interoperability, and other   advanced functionality</p> </li> <li> <p>Powerful API for integration with other web applications</p> </li> </ul> <p>See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.</p>"},{"location":"static/node_modules/mathjax/#mathjax-components","title":"MathJax Components","text":"<p>MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS.  Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way.  For usage instructions, see the MathJax documentation.</p> <p>Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server.  There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.</p>"},{"location":"static/node_modules/mathjax/#whats-in-this-repository","title":"What's in this Repository","text":"<p>This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository).  These component files are the ones served by the CDNs that offer MathJax to the web.  In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser.</p> <p>The components are stored in the <code>es5</code> directory, and are in ES5 format for the widest possible compatibility.  In the future, we may make an <code>es6</code> directory containing ES6 versions of the components.</p>"},{"location":"static/node_modules/mathjax/#installation-and-use","title":"Installation and Use","text":""},{"location":"static/node_modules/mathjax/#using-mathjax-components-from-a-cdn-on-the-web","title":"Using MathJax components from a CDN on the web","text":"<p>If you are loading MathJax from a CDN into a web page, there is no need to install anything.  Simply use a <code>script</code> tag that loads MathJax from the CDN.  E.g.,</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>See the MathJax documentation, the MathJax Web Demos, and the MathJax Component Repository for more information.</p>"},{"location":"static/node_modules/mathjax/#hosting-your-own-copy-of-the-mathjax-components","title":"Hosting your own copy of the MathJax Components","text":"<p>If you want to host MathJax from your own server, you can do so by installing the <code>mathjax</code> package using <code>npm</code> and moving the <code>es5</code> directory to an appropriate location on your server:</p> <pre><code>npm install mathjax@3\nmv node_modules/mathjax/es5 &lt;path-to-server-location&gt;/mathjax\n</code></pre> <p>Note that we are still making updates to version 2, so include <code>@3</code> when you install, since the latest chronological version may not be version 3.</p> <p>Alternatively, you can get the files via GitHub:</p> <pre><code>git clone https://github.com/mathjax/MathJax.git mj-tmp\nmv mj-tmp/es5 &lt;path-to-server-location&gt;/mathjax\nrm -rf mj-tmp\n</code></pre> <p>Then (in either case) you can use a script tag like the following:</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"&lt;url-to-your-site&gt;/mathjax/tex-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>where <code>&lt;url-to-your-site&gt;</code> is replaced by the URL to the location where you moved the MathJax files above.</p> <p>See the documentation for details.</p>"},{"location":"static/node_modules/mathjax/#using-mathjax-components-in-a-node-application","title":"Using MathJax components in a node application","text":"<p>To use MathJax components in a node application, install the <code>mathjax</code> package:</p> <pre><code>npm install mathjax@3\n</code></pre> <p>(we are still making updates to version 2, so you should include <code>@3</code> since the latest chronological version may not be version 3).</p> <p>Then require <code>mathjax</code> within your application:</p> <pre><code>require('mathjax').init({ ... }).then((MathJax) =&gt; { ... });\n</code></pre> <p>where the first <code>{ ... }</code> is a MathJax configuration, and the second <code>{ ... }</code> is the code to run after MathJax has been loaded.  E.g.</p> <pre><code>require('mathjax').init({\nloader: {load: ['input/tex', 'output/svg']}\n}).then((MathJax) =&gt; {\nconst svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true});\nconsole.log(MathJax.startup.adaptor.outerHTML(svg));\n}).catch((err) =&gt; console.log(err.message));\n</code></pre> <p>Note: this technique is for node-based application only, not for browser applications.  This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's <code>require()</code> command to load external modules.  This setup will not work properly in the browser, even if you webpack it or bundle it in other ways.</p> <p>See the documentation and the MathJax Node Repository for more details.</p>"},{"location":"static/node_modules/mathjax/#reducing-the-size-of-the-components-directory","title":"Reducing the Size of the Components Directory","text":"<p>Since the <code>es5</code> directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the <code>tex-chtml.js</code> component, then you can remove the <code>tex-mml-chtml.js</code>, <code>tex-svg.js</code>, <code>tex-mml-svg.js</code>, <code>tex-chtml-full.js</code>, and <code>tex-svg-full.js</code> configurations, which will save considerable space.  Indeed, you should be able to remove everything other than <code>tex-chtml.js</code>, and the <code>input/tex/extensions</code>, <code>output/chtml/fonts/woff-v2</code>, <code>adaptors</code>, <code>a11y</code>, and <code>sre</code> directories.  If you are using the results only on the web, you can remove <code>adaptors</code> as well.</p> <p>If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove <code>a11y</code> and <code>sre</code> as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there).</p> <p>If you are using SVG rather than CommonHTML output (e.g., <code>tex-svg.js</code> rather than <code>tex-chtml.js</code>), you can remove the <code>output/chtml/fonts/woff-v2</code> directory.  If you are using MathML input rather than TeX (e.g., <code>mml-chtml.js</code> rather than <code>tex-chtml.js</code>), then you can remove <code>input/tex/extensions</code> as well.</p>"},{"location":"static/node_modules/mathjax/#the-component-files-and-pull-requests","title":"The Component Files and Pull Requests","text":"<p>The <code>es5</code> directory is generated automatically from the contents of the MathJax source repository.  You can rebuild the components using the command</p> <pre><code>npm run make-es5 --silent\n</code></pre> <p>Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the <code>es5</code> directory.  If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository.</p>"},{"location":"static/node_modules/mathjax/#mathjax-community","title":"MathJax Community","text":"<p>The main MathJax website is http://www.mathjax.org, and it includes announcements and other important information.  A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub.</p> <p>Before reporting a bug, please check that it has not already been reported.  Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.</p>"},{"location":"static/node_modules/mathjax/#mathjax-resources","title":"MathJax Resources","text":"<ul> <li>MathJax Documentation</li> <li>MathJax Components</li> <li>MathJax Source Code</li> <li>MathJax Web Examples</li> <li>MathJax Node Examples</li> <li>MathJax Bug Tracker</li> <li>MathJax Users' Group</li> </ul>"}]}